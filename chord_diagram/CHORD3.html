<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Plot</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
    <div id="chordDiagram"></div>

    <script>





        const categories = [
            "Patients data", "Cell lines data", "Drug combinations",
            "Drug-target interactions", "Drug-disease links", "Gene-disease links", "Cancer mutations",
            "Chemical structures", "Protein structures", "Toxicities", "Pathways", "Docking",
            "Homology modelling", "Binding sites", "Combination web-tools", "Target based DR", "Phenotypic DR", "Toxicity assessment", "Design new clinical trials",
            "Mapping of diseases pathways", "Disease-specific", "Disease-agnostic", "Biomarker identification",
            "Predict adverse reactions"
        ];

        // Define the data

        d3.csv("chord_plot_updated.csv")
            .then(function (data) {
                var rowHeaders = [];
                var colHeaders = [];
                var matrixData = [];

                data.forEach(function (entry) {
                    var keys = Object.keys(entry);
                    var values = entry[keys[0]].split(';');

                    var rowHeader = keys[0].trim();
                    rowHeaders.push(rowHeader);

                    values.forEach(function (value, index) {
                        if (index > 0) {
                            var colHeader = value.trim().split(';')[0];
                            if (!colHeaders.includes(colHeader)) {
                                colHeaders.push(colHeader);
                            }
                        }
                    });

                    matrixData.push(values.slice(1).map(Number));
                });

                // Creating n x n matrix
                var n = rowHeaders.length;
                var matrix = new Array(n).fill(0).map(() => new Array(n).fill(0));

                matrixData.forEach(function (row, rowIndex) {
                    row.forEach(function (value, colIndex) {
                        matrix[rowIndex][colIndex] = value;
                    });
                });

                console.log(matrix);



                // Define dimensions for the plot
                const width = 800;
                const height = 800;
                const outerRadius = Math.min(width, height) * 0.5 - 40;
                const innerRadius = outerRadius - 30;

                // Create the chord layout
                const chord = d3.chord()
                    .padAngle(0.05)
                    .sortSubgroups(d3.descending)
                    .sortChords(d3.descending);

                // Create the SVG
                const svg = d3.select("#chordDiagram")
                    .append("svg")
                    .attr("viewBox", [-width / 2, -height / 2, width * 2, height * 2])
                    // .attr("width", "100%")
                    // .attr("height", "auto")
                    .attr("font-size", 12)
                    .attr("font-family", "sans-serif");

                // Define the colors
                const color = d3.scaleOrdinal()
                    .domain(d3.range(matrix.length))
                    .range(d3.schemeCategory10);

                // Compute the chord layout
                const chords = chord(matrix);
                console.log(chords)


                const filteredGroups = chords.groups.filter(group => {
                    console.log("here is the group ", group)

                    // return chords.groups.find(g => g.source.index === group.index || g.target.index === group.index);
                });

                // Add the groups
                const group = svg.append("g")
                    .selectAll("g")
                    .data(chords.groups)
                    .join("g");

                // Add the arcs for the groups
                group.append("path")
                    .attr("fill", d => color(d.index))
                    .attr("stroke", d => d3.rgb(color(d.index)).darker())
                    .attr("d", d3.arc()
                        .innerRadius(innerRadius)
                        .outerRadius(outerRadius)
                    );

                // Add the group labels
                group.append("text")
                    .each(d => (d.angle = (d.startAngle + d.endAngle) / 2))
                    .attr("dy", ".35em")
                    .attr("transform", d => `
                rotate(${(d.angle * 180 / Math.PI - 90)})
                translate(${innerRadius + 10})
                ${d.angle > Math.PI ? "rotate(180)" : ""}
            `)
                    .attr("text-anchor", d => d.angle > Math.PI ? "end" : null)
                    .text((d, i) => categories[i]);

                // Add the chords
                svg.append("g")
                    .attr("fill-opacity", 0.67)
                    .selectAll("path")
                    .data(chords)
                    .join("path")
                    .attr("d", d3.ribbon()
                        .radius(innerRadius)
                    )
                    .attr("fill", d => color(d.source.index))
                    .attr("stroke", d => d3.rgb(color(d.source.index)).darker());



            })
            .catch(error => {
                console.error('Error fetching or parsing CSV data:', error);
            });
        // Split the data into rows





    </script>
</body>

</html>