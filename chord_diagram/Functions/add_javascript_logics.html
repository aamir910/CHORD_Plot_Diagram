<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.0/xlsx.full.min.js"></script>

</head>

<body>
    <script>
        function updateKeys(obj) {
            const variations = ["dob", "birth"];
            const zipVariations = ["zip", "Zip", "ZIP"];
            const updatedKey = "CalendarYearBirth";
            const updatedGenderKey = "Gender";
            const updatedZipkey = "Zip3";
            const updatedEmployekey = "Employee";

            for (const key in obj) {
                const lowerCaseKey = key.toLowerCase();

                for (const variation of variations) {
                    if (lowerCaseKey.includes(variation.toLowerCase())) {
                        if (key === updatedKey) {
                            let dateOfBirth;
                            if (obj[key].length > 4 && isNumericString(obj[key])) {
                                dateOfBirth = convertSerialToDate(obj[key]);
                            } else {
                                dateOfBirth = obj[key];
                            }

                            let year = extractYear(dateOfBirth);
                            if (!year) {
                                year = extractYearFromDate(dateOfBirth);
                            }
                            obj[updatedKey] = year;
                        } else {
                            let dateOfBirth;
                            if (obj[key].length > 4 && isNumericString(obj[key])) {
                                dateOfBirth = convertSerialToDate(obj[key]);
                                console.log(dateOfBirth)
                            } else {
                                dateOfBirth = obj[key];
                            }

                            let year = extractYear(dateOfBirth);
                            if (!year) {
                                year = extractYearFromDate(dateOfBirth);
                            }

                            const convertedDate = checkAndConvertDate(dateOfBirth);
                            console.log("Original Date:", dateOfBirth);
                            console.log("Converted Date:", convertedDate);
                            obj[updatedKey] = year;
                            obj[`${updatedKey}2`] = convertedDate;

                            delete obj[key];
                        }
                        break; // Assuming only one matching key should be updated
                    }
                }

                if (lowerCaseKey === "gender" || lowerCaseKey === "sex") {
                    if (key != updatedGenderKey) {
                        obj[updatedGenderKey] = obj[key];
                        delete obj[key];
                    }
                    const genderValue = obj[updatedGenderKey].toLowerCase();
                    if (genderValue.includes("female") || genderValue.includes("f")) {
                        obj[updatedGenderKey] = "F";
                    } else if (
                        genderValue.includes("male") ||
                        genderValue.includes("m")
                    ) {
                        obj[updatedGenderKey] = "M";
                    } else {
                        obj[updatedGenderKey] = "Unknown";
                    }
                }

                if (lowerCaseKey.includes("zip")) {
                    if (key !== updatedZipkey) {
                        obj[updatedZipkey] = obj[key];
                        delete obj[key];
                    }

                    if (isNumericString(obj[updatedZipkey])) {
                        obj[updatedZipkey] =
                            obj[updatedZipkey].length >= 1
                                ? obj[updatedZipkey].slice(0, 3)
                                : "Unknown";
                    } else {
                        obj[updatedZipkey] = "Unknown";
                    }
                }
                if (
                    lowerCaseKey === "employee" ||
                    lowerCaseKey === "employe" ||
                    lowerCaseKey === "coverage"
                ) {
                    if (key != updatedEmployekey) {
                        obj[updatedEmployekey] = obj[key];
                        delete obj[key];
                    }

                    const employeeValue = obj[updatedEmployekey].toLowerCase();

                    if (employeeValue.length > 2) {
                        if (
                            employeeValue.includes("family") ||
                            employeeValue.includes("all")
                        ) {
                            obj[updatedEmployekey] = "F";
                        } else if (
                            employeeValue === "only" ||
                            employeeValue === "single"
                        ) {
                            obj[updatedEmployekey] = "EE";
                        } else if (
                            employeeValue.includes("spouse") ||
                            employeeValue.includes("partner") ||
                            employeeValue.includes("wife")
                        ) {
                            obj[updatedEmployekey] = "ES";
                        } else if (
                            employeeValue.includes("child") ||
                            employeeValue.includes("chdrn")
                        ) {
                            obj[updatedEmployekey] = "EC";
                        } else {
                            obj[updatedEmployekey] = "Unknown";
                        }
                    }
                }
            }
            return obj;
        }
        function extractYearFromDate(dateString) {
            const date = new Date(dateString);

            const year = date.getFullYear();
            return year;
        }
        function extractYear(dateString) {
            if (typeof dateString === "string") {
                const numericalYearMatch = dateString.match(/\b\d{4}\b/);

                if (numericalYearMatch) {
                    return numericalYearMatch[0];
                } else {
                    const date = new Date(dateString);

                    if (!isNaN(date)) {
                        return date.getFullYear();
                    } else {
                        return null;
                    }
                }
            } else {
                return dateString; // Return the same value if not a string
            }
        }
        // Function to convert date to the desired format
        function convertDateFormat(dateStr) {
            const [day, month, year] = dateStr.match(/\d+/g);
            return `${day}-${month}-${year}`;
        }

        // Check if any pattern exists in dateOfBirth and convert if found
        function checkAndConvertDate(dateOfBirth) {
            const patterns = [
                /\b\d{1,2}\s+\w+\s+\d{2,4}\b/,     // e.g., 10 July 2000
                /\b\d{1,2}[/-]\d{1,2}[/-]\d{2,4}\b/,  // e.g., 10/12/2000 or 3-3-2000
                /\b\d{1,2}\.\d{1,2}\.\d{2,4}\b/,  // e.g., 10.12.2000
                /\b\d{1,2}\s+\w{3,}\s+\d{4}\b/,     // e.g., 10 December 2000
                /\b\d{1,2}\s+\w{3,}\s+\d{2}\b/,     // e.g., 10 December 00
                /\b\d{1,2}\s+\w{3}\s+\d{4}\b/,     // e.g., 10 Dec 2000
                /\b\d{1,2}\s+\w{3}\s+\d{2}\b/,     // e.g., 10 Dec 00
                /\b\w{3,}\s+\d{1,2},\s+\d{4}\b/,     // e.g., December 10, 2000
                /\b\w{3}\s+\d{1,2},\s+\d{4}\b/,     // e.g., Dec 10, 2000
                /\b\w{3,}\s+\d{1,2}\s+\d{4}\b/,     // e.g., December 10 2000
                /\b\w{3}\s+\d{1,2}\s+\d{4}\b/      // e.g., Dec 10 2000
            ];

            for (const pattern of patterns) {
                if (pattern.test(dateOfBirth)) {
                    // If pattern found, convert it to the desired format
                    const convertedDate = convertDateFormat(dateOfBirth);
                    return convertedDate;
                }
            }

            // If no pattern found, return original date
            return dateOfBirth;
        }


        function isNumericString(str) {
            return /^\d+$/.test(str);
        }

        function hasUnknownValue(obj) {
            for (const key in obj) {
                if (obj[key] === "Unknown") {
                    return true;
                }
            }
            return false;
        }
        function convertSerialToDate(serialNumberStr) {
            // Convert the serial number string to a number
            var serialNumber = parseInt(serialNumberStr);

            // Convert serial number to milliseconds since epoch
            var millisecondsSinceEpoch = (serialNumber - 1) * 24 * 60 * 60 * 1000;

            // Create a new Date object
            var date = new Date(
                millisecondsSinceEpoch + new Date("1899-12-30").getTime()
            );

            // Extract the date components
            var day = date.getDate();
            var month = date.getMonth() + 1; // Month is zero-indexed, so add 1
            var year = date.getFullYear();

            // Format the date
            var formattedDate = day + "-" + month + "-" + year;

            return formattedDate;
        }

        const objects = [
            {
                CalendarYearBirth: "12/24/1967",
                sex: "nmale",
                Zip3: "12345",
                employe: "partner",
            },
            {
                DOB: "12/24/1967",
                gender: "m",
                ZIP2: "12313131",
                Employee: "F",
            },
        ];

        const object3 = [
            {
                CalendarYearBirth: 3 - 3 - 2200,
                Gender: "M",
                Zip3: 100,
                Employee: "ALL",
            },

            {
                dob: "10/12/2003",
                Gender: "M",
                "Zip Code": "76106",
                Employee: "Single",
            },
            {
                dob: 36413,
                Gender: "M",
                "Zip Code": "76182",
                Employee: "Single",
            },
            {
                dob: 36605,
                Gender: "M",
                "Zip Code": "76116",
                Employee: "Single",
            },


            {
                dob: 37162,
                Gender: "M",
                "Zip Code": "93552",
                Employee: "Single",
            },
            {
                dob: 37259,
                Gender: "M",
                "Zip Code": "76106",
                Employee: "Single",
            },
            // {
            //     dob: 37746,
            //     Gender: "M",
            //     "Zip Code": "76111",
            //     Employee: "Single",
            // },
            // {
            //     dob: 38013,
            //     Gender: "F",
            //     "Zip Code": "92354",
            //     Employee: "Single",
            // },
            // {
            //     dob: 38203,
            //     Gender: "M",
            //     "Zip Code": "76115",
            //     Employee: "Single",
            // },
        ];

        const objectsToString = object3.map((obj) => {
            const newObj = {};
            for (const key in obj) {
                newObj[key] = String(obj[key]);
            }
            return newObj;
        });

        const updatedObjects = objectsToString.map(updateKeys);

        console.log(updatedObjects, "here is the final object");


        async function fetchExcelAndConvertToJson(filePath) {
            try {
                const response = await fetch(filePath);
                const arrayBuffer = await response.arrayBuffer();
                const data = new Uint8Array(arrayBuffer);
                const workbook = XLSX.read(data, { type: 'array' });
                const sheetName = workbook.SheetNames[0];
                const sheet = workbook.Sheets[sheetName];
                return XLSX.utils.sheet_to_json(sheet, { header: 1 });
            } catch (error) {
                console.error('Error fetching or parsing file:', error);
                throw error; // Rethrow the error to be handled by the caller
            }
        }
        async function main() {
            try {
                const Base_Net_Monthly_Prem_Table = await fetchExcelAndConvertToJson("xlxsfile/Base_Net_Monthly_Prem_Table.xlsx");
                const Random_Zip_Generator = await fetchExcelAndConvertToJson("xlxsfile/Random_Zip_Generator.xlsx");
                const Zip_Table = await fetchExcelAndConvertToJson("xlxsfile/Zip_Table.xlsx");
                const Age_Gender_Factor_1 = await fetchExcelAndConvertToJson("xlxsfile/Age_Gender_Factor_1.xlsx");
                const Age_Gender_Factor_2 = await fetchExcelAndConvertToJson("xlxsfile/Age_Gender_Factor_2.xlsx");


                // Your processing logic here
                console.log(Base_Net_Monthly_Prem_Table, "Base_Net_Monthly_Prem_Table");
                console.log(Random_Zip_Generator, "Random_Zip_Generator");
                console.log(Age_Gender_Factor_1, "Age_Gender_Factor_1");
                console.log(Age_Gender_Factor_2, "Age_Gender_Factor_2");

                console.log(Zip_Table, "Zip_Table");

                function findTableForZip(zip, data) {
                    for (let i = 0; i < data.length; i++) {
                        if (data[i][0] === zip) {
                            return data[i][2];
                        }
                    }
                    return null; // Return null if no match is found
                }
                function customFormula_ziptablealpha(I2) {
                    if (I2 === "I" || I2 === "J" || I2 === "K" || I2 === "L") {
                        if (I2 === "I" || I2 === "J") {
                            return "I,J";
                        } else {
                            return "K,L";
                        }
                    } else {
                        return I2;
                    }
                }
                function getValueByLabelAndIndex(data, label, index) {
                    for (let i = 0; i < data.length; i++) {
                        const innerList = data[i];
                        if (innerList[0] === label) {
                            if (index < innerList.length) {
                                return innerList[index];
                            } else {
                                return null;  // Index out of range for this inner list
                            }
                        }
                    }
                    return null;  // Label not found in the data
                }
                // Function to calculate sumproduct
                function calculateSumproduct(data) {
                    let sumproduct = 0;
                    for (const entry of data) {
                        sumproduct += entry.M * entry.Member_count;
                    }
                    return sumproduct;
                }
                function calculateSumproduct2(data) {
                    let sumproduct = 0;
                    for (const entry of data) {
                        sumproduct += entry.P * entry.Member_count;
                    }
                    return sumproduct;
                }

                function calculateValueOF_O(N5, O5, B32, B33, B31) {
                    let result;
                    if (N5 === O5) {
                        result = N5;
                    } else {
                        result = N5 + ((O5 - N5) / (B33 - B32)) * (B31 - B32);
                    }
                    return result;
                }
                function calculateValueOF_S(Q2, R2, B36, B37, B35) {
                    if (Q2 === R2) {
                        return Q2;
                    } else {
                        return Q2 + ((R2 - Q2) / (B37 - B36)) * (B35 - B36);
                    }
                }
                function calculateValueOFLine3(C7, B9, B23, B28) {
                    if (C7 === 8) {
                        return (B9 - 1) * (B23 - B28);
                    } else {
                        return 0;
                    }
                }

                function calculateValueOfLine4(C7, B20, B23, B28) {
                    if (C7 === 6) {
                        return (B20 - 1) * (B23 - B28);
                    } else {
                        return 0;
                    }
                }

                function calculateAgeGender(dependent_participation_rate) {
                    // Map ranges to corresponding age_gender values
                    const ranges = [
                        { min: 0, max: 49, value: 1.08 },
                        { min: 50, max: 59, value: 1.03 },
                        { min: 60, max: 69, value: 1.00 },
                        { min: 70, max: 79, value: 0.95 },
                        { min: 80, max: 89, value: 0.90 },
                        { min: 90, max: 99, value: 0.88 },
                        { min: 100, max: Infinity, value: 0.85 }
                    ];

                    // Find the range that includes dependent_participation_rate
                    const range = ranges.find(range => dependent_participation_rate >= range.min && dependent_participation_rate <= range.max);

                    // Return the corresponding age_gender value
                    return range ? range.value : null;
                }
                let updatedObjects2 = JSON.parse(JSON.stringify(updatedObjects));



                let Individual_Attachment_point = 5000;
                Annual_Maximum_Incl_attachment_point = 500000;
                let plan = 6;
                let runin_month = 100;
                let runout_month = 105;
                let annual_max = 500000;
                let calendar_year = 200;
                let coverage_next_5000 = 100;
                let EE_oop_max = 2000;
                let industry = 1.005;
                let dependent_participation_rate = 100;
                let annual_stop_loss_limit = "none";
                let type_of_UW = "Type II";
                let date_begins = "2000";
                let Coverage_for_next_$5000 = 80;


                // for the net primium value

                let Industry_Factor = 1.025;
                let age_gender = 0;
                let Dependent_Participation_Factor = calculateAgeGender(dependent_participation_rate);

                // creating the opp mac calc    


                const table3 = [
                    ["Office Visits", 13, 20],
                    ["Hospital Inpatient per stay", 0.8, 10],
                    ["Hospital Inpatient per day", 3.7, 15],
                    ["Outpatient Surgical Center", 0.9, 30],
                    ["CT Scan/MRI", 1, 20],
                    ["Emergency Room", 0.9, 60],
                    ["Prescription Drug – Generic", 24.1, 15],
                    ["Prescription Drug – Without Specialty – Brand Name Formulary", 3.6, 20],
                    ["Prescription Drug – Without Specialty – Brand Name Non-Formulary", 2.4, 20],
                    ["Prescription Drug – With Specialty – Brand Name Formulary", 3.3, 20],
                    ["Prescription Drug – With Specialty – Brand Name Non-Formulary", 2.2, 20],
                    ["Prescription Drug – With Specialty – Specialty", 0.5, 15]
                ];

                let sum = 0;


                for (let i = 0; i < table3.length; i++) {
                    sum += table3[i][1] * table3[i][2];
                }



                let B23 = Coverage_for_next_$5000 / 100; // b12 fromt he 2 input 
                let B24 = calendar_year;
                let B25 = EE_oop_max;
                let B26 = Math.ceil((B25 - B24) * (1 - B23));
                let B27 = sum;
                let B28 = Math.ceil(B24 + B26 + B27);
                let B29 = 1200
                let B30 = (B29 === B25) ? 0 : B28;
                let B31 = B30 + Individual_Attachment_point;
                console.log(B28, "here is the b ", B31);

                const targetValue = B31; // Example value you provided

                const values = [
                    5000, 7500, 10000, 12500, 15000, 17500, 20000, 22500, 25000, 30000,
                    35000, 40000, 45000, 50000, 55000, 60000, 65000, 70000, 75000, 80000,
                    85000, 90000, 95000, 100000, 105000, 110000, 115000, 120000, 125000,
                    130000, 135000, 140000, 145000, 150000, 155000, 160000, 165000, 170000,
                    175000, 180000, 185000, 190000, 195000, 200000, 205000, 210000, 215000,
                    220000, 225000, 230000, 235000, 240000, 245000, 250000, 275000, 300000,
                    325000, 350000, 375000, 400000, 425000, 450000, 475000, 500000, 550000,
                    600000, 650000, 700000, 750000, 800000, 900000, 1000000, 1250000, 1500000,
                    2000000, 2500000, 3000000, 4000000, 5000000, 10000000
                ];

                // Find the nearest lower value
                let B32 = -Infinity;
                for (let i = 0; i < values.length; i++) {
                    if (values[i] < targetValue && values[i] > B32) {
                        B32 = values[i];
                    }
                }
                let B33 = Infinity;
                for (let i = 0; i < values.length; i++) {
                    if (values[i] > targetValue && values[i] < B33) {
                        B33 = values[i];
                    }
                }
                let B35 = Annual_Maximum_Incl_attachment_point + B28
                console.log(B35, "here is ");

                const targetvalue2 = B35;
                // Find the nearest higher value

                // Find the nearest lower value
                let B36 = -Infinity;
                for (let i = 0; i < values.length; i++) {
                    if (values[i] < targetvalue2 && values[i] > B36) {
                        B36 = values[i];
                    }
                }

                // Find the nearest higher value
                let B37 = Infinity;
                for (let i = 0; i < values.length; i++) {
                    if (values[i] > targetvalue2 && values[i] < B37) {
                        B37 = values[i];
                    }
                }
                console.log(B36, B37, "here are the last value of the b36 and the b37 ");


                // here are the B9 
                let B9 = runin_month;
                let B20 = runout_month;


                updatedObjects2.forEach((entry, index) => {

                    switch (entry.Employee) {
                        case "EE":
                            entry.Member_count = 1;
                            break;
                        case "ES":
                            entry.Member_count = 2.2;
                            break;
                        case "EC":
                            entry.Member_count = 2.2;
                            break;
                        case "F":
                            entry.Member_count = 4.2;
                            break;
                        default:
                            // Handle unknown employee types
                            break;
                    }
                    // addded the age
                    entry.Age_Last = parseInt(date_begins) - parseInt(entry.CalendarYearBirth);
                    // added the age bucket 

                    if (entry.Age_Last < 30) {
                        entry.age_bucket = "Under 30";
                    } else if (entry.Age_Last >= 30 && entry.Age_Last < 35) {
                        entry.age_bucket = "30 – 34";
                    } else if (entry.Age_Last >= 35 && entry.Age_Last < 40) {
                        entry.age_bucket = "35 – 39";
                    } else if (entry.Age_Last >= 40 && entry.Age_Last < 45) {
                        entry.age_bucket = "40 – 44";
                    } else if (entry.Age_Last >= 45 && entry.Age_Last < 50) {
                        entry.age_bucket = "45 – 49";
                    } else if (entry.Age_Last >= 50 && entry.Age_Last < 55) {
                        entry.age_bucket = "50 – 54";
                    } else if (entry.Age_Last >= 55 && entry.Age_Last < 60) {
                        entry.age_bucket = "55 – 59";
                    } else if (entry.Age_Last >= 60 && entry.Age_Last < 65) {
                        entry.age_bucket = "60 – 64";
                    } else if (entry.Age_Last >= 65 && entry.Age_Last < 70) {
                        entry.age_bucket = "65 – 69";
                    } else {
                        entry.age_bucket = "70 & Over";
                    }

                    // added the 3 digit zip code 

                    entry.zip_code_3 = Random_Zip_Generator[index + 1][2].substring(0, 3);
                    // zip to alphabet 

                    entry.Zip_table_alpha = findTableForZip(entry.zip_code_3, Zip_Table)
                    entry.Base_Net_Monthly_Prem_lookupvalue = customFormula_ziptablealpha(entry.Zip_table_alpha)
                    entry.M = getValueByLabelAndIndex(Base_Net_Monthly_Prem_Table,
                        `${entry.Base_Net_Monthly_Prem_lookupvalue},${Individual_Attachment_point}`, plan - 1)
                    entry.N = getValueByLabelAndIndex(Base_Net_Monthly_Prem_Table,
                        `${entry.Base_Net_Monthly_Prem_lookupvalue},${B32}`, plan - 1)
                    entry.O = getValueByLabelAndIndex(Base_Net_Monthly_Prem_Table,
                        `${entry.Base_Net_Monthly_Prem_lookupvalue},${B33}`, plan - 1)
                    entry.P = calculateValueOF_O(entry.N, entry.O, B32, B33, B31)
                    entry.Q = getValueByLabelAndIndex(Base_Net_Monthly_Prem_Table,
                        `${entry.Base_Net_Monthly_Prem_lookupvalue},${B36}`, plan - 1)
                    entry.R = getValueByLabelAndIndex(Base_Net_Monthly_Prem_Table,
                        `${entry.Base_Net_Monthly_Prem_lookupvalue},${B37}`, plan - 1)
                    entry.S = calculateValueOF_O(entry.Q, entry.R, B36, B37, B35);
                });


                let totalMemberCount = updatedObjects2.reduce(
                    (total, entry) => total + entry.Member_count,
                    0
                );


                totalMemberCount *= 3;
                let roundedMemberCount =
                    totalMemberCount % 1 >= 0.5
                        ? Math.ceil(totalMemberCount)
                        : Math.floor(totalMemberCount);
                employeeCount = updatedObjects2.length * 3;


                const Net_Premium_before_OOP = calculateSumproduct(updatedObjects2);
                const Line_1a = calculateSumproduct2(updatedObjects2) - Net_Premium_before_OOP;
                let adjacent_based_rate = Net_Premium_before_OOP + Line_1a;

                let sumOfS = 0;

                updatedObjects2.forEach(obj => {
                    sumOfS += obj.S;
                });

                console.log("Sum of S:", sumOfS);
                let B28_main;
                if (Annual_Maximum_Incl_attachment_point == "") {
                    B28_main = 0;
                } else {
                    B28_main = - sumOfS
                }
                // calcuation of the age factor  

                let male_point;
                let female_point;
                if (Individual_Attachment_point < 25000) {
                    male_point = 1 + 1;
                    female_point = male_point + 1;
                } else if (Individual_Attachment_point <= 99999) {
                    male_point = 3 + 1;
                    female_point = male_point + 1;
                } else if (Individual_Attachment_point <= 249999) {
                    male_point = 5 + 1;
                    female_point = male_point + 1;
                } else if (Individual_Attachment_point <= 499999) { // Add an additional condition for Individual_Attachment_point <= 499999
                    male_point = 7 + 1;
                    female_point = male_point + 1;
                }


                console.log(male_point, "male", female_point, "female")



                const ageBuckets = [
                    "Under 30",
                    "30 – 34",
                    "35 – 39",
                    "40 – 44",
                    "45 – 49",
                    "50 – 54",
                    "55 – 59",
                    "60 – 64",
                    "65 – 69",
                    "70 & Over",
                    "Retired – Medicare Primary"
                ];
                let male_female_array = [];

                ageBuckets.forEach(bucket => {
                    const countMale = countRowsByGenderAndAgeBucket(updatedObjects2, "M", bucket);
                    const countFemale = countRowsByGenderAndAgeBucket(updatedObjects2, "F", bucket);
                    const countMale2 = countRowsByGenderAndAgeBucket2(updatedObjects2, "M", bucket);
                    const countFemale2 = countRowsByGenderAndAgeBucket2(updatedObjects2, "F", bucket);

                    console.log(`Age Bucket: ${bucket}`);
                    console.log(`Number of rows with Gender=M: ${countMale}`);
                    console.log(`Number of rows with Gender=F: ${countFemale}`);
                    console.log("--------");
                    console.log(`Number of rows with Gender=M2: ${countMale2}`);
                    console.log(`Number of rows with Gender=F2: ${countFemale2}`);
                    console.log("--------");

                    male_female_array.push([bucket, countMale, countFemale, countMale2, countFemale2]);


                });
                console.log(male_female_array, 'male_female_array');

                function countRowsByGenderAndAgeBucket(data, gender, ageBucket) {
                    return data.filter(row => row.Gender === gender && row.age_bucket === ageBucket && row.Member_count === 1).length;
                }
                function countRowsByGenderAndAgeBucket2(data, gender, ageBucket) {
                    return data.filter(row => row.Gender === gender && row.age_bucket === ageBucket && row.Member_count > 1).length;
                }

                const cal_count_factor_m_f = male_female_array.map((m1, index) => ({

                    m1: male_female_array[index][3],
                    f1: male_female_array[index][4],
                    m2: Age_Gender_Factor_1[index + 1][male_point],
                    f2: Age_Gender_Factor_1[index + 1][female_point]
                }));


                const cal_count_factor_m_f_2 = male_female_array.map((m1, index) => ({

                    m1: male_female_array[index][1],
                    f1: male_female_array[index][2],
                    m2: Age_Gender_Factor_2[index + 1][male_point - 1],
                    f2: Age_Gender_Factor_2[index + 1][female_point - 1]
                }));

                function calculateSum(array, property) {
                    return array.reduce((acc, obj) => acc + obj[property], 0);
                }

                // Usage
                const sumM1 = calculateSum(cal_count_factor_m_f, 'm1');
                const sumF1 = calculateSum(cal_count_factor_m_f, 'f1');


                const sum2M1 = calculateSum(cal_count_factor_m_f_2, 'm1');
                const sum2F1 = calculateSum(cal_count_factor_m_f_2, 'f1');


                console.log("Sum of m1:", sum2M1);
                console.log("Sum of f1:", sum2F1);

                function calculateSumProduct(array, property1, property2) {
                    return array.reduce((acc, obj) => acc + (obj[property1] * obj[property2]), 0);
                }

                // Usage
                const sumProductF2 = calculateSumProduct(cal_count_factor_m_f, 'f1', 'f2');
                const sumProductM2 = calculateSumProduct(cal_count_factor_m_f, 'm1', 'm2');

                const sumProduct2F2 = calculateSumProduct(cal_count_factor_m_f_2, 'f1', 'f2');
                const sumProduc2M2 = calculateSumProduct(cal_count_factor_m_f_2, 'm1', 'm2');




                let age_gender_vector_sum = sumM1 + sumF1 + sum2M1 + sum2F1

                let count_sum = sumProductF2 + sumProductM2 + sumProduct2F2 + sumProduc2M2

                let factor = age_gender_vector_sum / count_sum;



                console.log("Sum of the product of f1 and f2:", sumProductF2);
                console.log("Sum of the product of m1 and m2:", sumProductM2);
                console.log("factor:", factor);

                age_gender = factor;


                console.log(cal_count_factor_m_f, cal_count_factor_m_f_2, "here is the final value female_point");
                console.log(updatedObjects2, "ADDED THE MEMBER COUNT ");
                console.log("Member count :", roundedMemberCount);
                console.log("Employee count:", employeeCount);
                console.log("Individual Attachment point :", Individual_Attachment_point);
                console.log("Plan:", plan);
                console.log("Run In, note months:", runin_month);
                console.log("Run out, note months:", runout_month);
                console.log("Annual Maximum Incl attachment point:", annual_max);
                console.log("Calendar year deductible:", calendar_year);
                console.log("Coverage for next $5000:", coverage_next_5000);
                console.log("EE OOP max (incl deductible):", EE_oop_max);
                console.log("Industry:", industry);
                console.log("Dependent Participation Rate:", dependent_participation_rate);
                console.log("Annual Stop Loss limit:", annual_stop_loss_limit);
                console.log("Type of UW:", type_of_UW);

                let adjustment_run_in = calculateValueOFLine3(plan, B9, adjacent_based_rate, B28_main);

                let adjustment_run_out = calculateValueOfLine4(plan, B20, adjacent_based_rate, B28_main);


                console.log("Line1: Base Net Premium before OOP Max adjustment:", Net_Premium_before_OOP.toFixed(2));


                console.log("Line1a: Base Net Premium before OOP Max adjustment:", Line_1a.toFixed(2));
                console.log("Line2: Base Net Premium before OOP Max adjustment:", adjacent_based_rate.toFixed(2));

                console.log("Line 3: Adjustment for Run-out", adjustment_run_in.toFixed(2));
                console.log("Line 4: Adjustment for Run-In", adjustment_run_out.toFixed(2));
                console.log("Adjustment for Annual Max Benefit:", B28_main.toFixed(2));

                let Adjusted_rate = adjacent_based_rate + adjustment_run_in + adjustment_run_out + B28_main

                console.log("Adjusted rate:", Adjusted_rate.toFixed(2));
                let net_priminum = Adjusted_rate * age_gender * Industry_Factor * Dependent_Participation_Factor

                console.log("Net Premium:", net_priminum.toFixed(2));
                // Rest of your code...
            } catch (error) {
                // Handle any errors occurred during the process
                console.error('An error occurred:', error);
            }
        }


        main();




    </script>
</body>

</html>